https://wokwi.com/projects/449264698756817921

#include <stdio.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_adc/adc_oneshot.h"
#include "esp_adc/adc_cali.h"
#include "esp_adc/adc_cali_scheme.h"
#include "esp_timer.h"

// Настройки АЦП
#define ADC_UNIT        ADC_UNIT_1
#define ADC_CHANNEL     ADC_CHANNEL_4   // GPIO32
#define ADC_ATTENUATION ADC_ATTEN_DB_12
#define SAMPLES         10              // Усреднение
#define CALIB_DURATION_MS 3000          // Время автокалибровки (мс)

// Температура (можно заменить на датчик позже)
#define TEMPERATURE     25.0f

static bool adc_calibration_init(adc_unit_t unit, adc_channel_t channel, adc_atten_t atten, adc_cali_handle_t *out_handle);
static void adc_calibration_deinit(adc_cali_handle_t handle);

// === Функция расчёта TDS по напряжению (после коррекции и темп-компенсации) ===
static float calculate_tds(float v_corrected)
{
    if (v_corrected <= 0.0f) return 0.0f;
    // Формула: TDS = 0.5 * (133.42*V^3 - 255.86*V^2 + 857.39*V)
    return 0.5f * (
        133.42f * v_corrected * v_corrected * v_corrected
        - 255.86f * v_corrected * v_corrected
        + 857.39f * v_corrected
    );
}

void app_main(void)
{
    // --- Инициализация АЦП ---
    adc_oneshot_unit_handle_t adc_handle;
    ESP_ERROR_CHECK(adc_oneshot_new_unit(&(adc_oneshot_unit_init_cfg_t){.unit_id = ADC_UNIT}, &adc_handle));
    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc_handle, ADC_CHANNEL, 
        &(adc_oneshot_chan_cfg_t){.bitwidth = ADC_BITWIDTH_DEFAULT, .atten = ADC_ATTENUATION}));

    // --- Калибровка АЦП ---
    adc_cali_handle_t cal_handle = NULL;
    bool do_cal = adc_calibration_init(ADC_UNIT, ADC_CHANNEL, ADC_ATTENUATION, &cal_handle);
    if (!do_cal) {
        printf("Warning: ADC calibration unavailable — results may be inaccurate!\n");
    }

    // --- Автокалибровка нуля (3 секунды при старте) ---
    printf(">>> Starting zero calibration (keep probe DRY & STILL for 3 sec)...\n");
    int64_t start = esp_timer_get_time();
    int sum_raw = 0, count = 0;
    while ((esp_timer_get_time() - start) < (CALIB_DURATION_MS * 1000)) {
        int raw;
        ESP_ERROR_CHECK(adc_oneshot_read(adc_handle, ADC_CHANNEL, &raw));
        sum_raw += raw;
        count++;
        vTaskDelay(pdMS_TO_TICKS(10));
    }
    int zero_raw = sum_raw / count;
    int zero_mv = 0;
    if (do_cal) {
        ESP_ERROR_CHECK(adc_cali_raw_to_voltage(cal_handle, zero_raw, &zero_mv));
    } else {
        // Грубая оценка без калибровки: 1100 мВ / 4096 ≈ 0.268 мВ/отсчёт
        zero_mv = (int)(zero_raw * 1100.0f / 4095.0f);
    }
    printf(">>> Zero calibration done: Raw=%d → %d mV (will subtract this offset)\n", zero_raw, zero_mv);

    // --- Основной цикл измерений ---
    printf("\n--- TDS Monitor (Zero offset: %d mV) ---\n", zero_mv);
    printf("Raw(mV) | Corr(mV) | TDS(ppm)\n");
    printf("-------------------------------\n");

    while (1) {
        // Усреднение SAMPLES измерений
        int sum_mv = 0;
        for (int i = 0; i < SAMPLES; i++) {
            int raw;
            ESP_ERROR_CHECK(adc_oneshot_read(adc_handle, ADC_CHANNEL, &raw));
            int mv = 0;
            if (do_cal) {
                ESP_ERROR_CHECK(adc_cali_raw_to_voltage(cal_handle, raw, &mv));
            } else {
                mv = (int)(raw * 1100.0f / 4095.0f);
            }
            sum_mv += mv;
            vTaskDelay(pdMS_TO_TICKS(5));
        }
        int avg_mv = sum_mv / SAMPLES;

        // Коррекция смещения
        int corrected_mv = avg_mv - zero_mv;
        if (corrected_mv < 0) corrected_mv = 0;

        // Температурная компенсация (если T ≠ 25°C — поправка)
        float v_adc = corrected_mv * 0.001f; // mV → V
        float v_tds = v_adc / (1.0f + 0.02f * (TEMPERATURE - 25.0f));

        // Расчёт TDS
        float tds = calculate_tds(v_tds);

        // Вывод
        printf("%7d | %8d | %7.1f\n", avg_mv, corrected_mv, tds);

        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    // --- Очистка (не достигается) ---
    ESP_ERROR_CHECK(adc_oneshot_del_unit(adc_handle));
    if (do_cal) adc_calibration_deinit(cal_handle);
}

// --- Вспомогательные функции калибровки (без изменений) ---
static bool adc_calibration_init(adc_unit_t unit, adc_channel_t channel, adc_atten_t atten, adc_cali_handle_t *out_handle)
{
    adc_cali_handle_t handle = NULL;
    esp_err_t ret = ESP_FAIL;
    bool calibrated = false;

#if ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED
    if (!calibrated) {
        adc_cali_curve_fitting_config_t cfg = {
            .unit_id = unit, .chan = channel, .atten = atten, .bitwidth = ADC_BITWIDTH_DEFAULT,
        };
        ret = adc_cali_create_scheme_curve_fitting(&cfg, &handle);
        if (ret == ESP_OK) calibrated = true;
    }
#endif
#if ADC_CALI_SCHEME_LINE_FITTING_SUPPORTED
    if (!calibrated) {
        adc_cali_line_fitting_config_t cfg = {
            .unit_id = unit, .atten = atten, .bitwidth = ADC_BITWIDTH_DEFAULT,
        };
        ret = adc_cali_create_scheme_line_fitting(&cfg, &handle);
        if (ret == ESP_OK) calibrated = true;
    }
#endif

    *out_handle = handle;
    return calibrated;
}

static void adc_calibration_deinit(adc_cali_handle_t handle)
{
#if ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED
    adc_cali_delete_scheme_curve_fitting(handle);
#elif ADC_CALI_SCHEME_LINE_FITTING_SUPPORTED
    adc_cali_delete_scheme_line_fitting(handle);
#endif
}
